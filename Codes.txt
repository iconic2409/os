========================================================================================================
Shell Script
-------------------------------------------------------------------------------------------------------
#!/bin/bash

echo "========== (i) OS Version, Release Number, and Kernel Version =========="
echo "OS Version: $(uname -o)"
echo "Release Number: $(cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2 | tr -d '\"')"
echo "Kernel Version: $(uname -r)"

echo -e "\n========== (ii) Top 10 Processes by Memory Usage (Descending Order) =========="
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head -n 11

echo -e "\n========== (iii) Current Logged-in User and Log Name =========="
echo "Current User: $USER"
echo "Log Name: $LOGNAME"

echo -e "\n========== (iv) Top 10 Memory-Hogging Processes =========="
ps aux --sort=-%mem | awk 'NR<=11{print $0}'

echo -e "\n========== (v) Current Shell, Home Directory, OS Type, Current Path =========="
echo "Current Shell: $SHELL"
echo "Home Directory: $HOME"
echo "OS Type: $(uname -s)"
echo "Current Path: $(pwd)"
----------------------------------------------------------------------------------------------------
save filename "sys.sh"
cmd1 :  chmod +x sys.sh
cmd2 : ./sys.sh

======================================================================================================
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
======================================================================================================

Implement CP in c 
------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

#define BUFFER_SIZE 1024

int main(int argc, char *argv[]) {
    FILE *sourceFile, *destFile;
    char buffer[BUFFER_SIZE];
    size_t bytesRead;

    if (argc != 3) {
        fprintf(stderr, "Usage: %s <source> <destination>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    sourceFile = fopen(argv[1], "rb");
    if (sourceFile == NULL) {
        perror("Error opening source file");
        exit(EXIT_FAILURE);
    }

    destFile = fopen(argv[2], "wb");
    if (destFile == NULL) {
        perror("Error opening destination file");
        fclose(sourceFile);
        exit(EXIT_FAILURE);
    }

    while ((bytesRead = fread(buffer, 1, BUFFER_SIZE, sourceFile)) > 0) {
        if (fwrite(buffer, 1, bytesRead, destFile) != bytesRead) {
            perror("Error writing to destination file");
            fclose(sourceFile);
            fclose(destFile);
            exit(EXIT_FAILURE);
        }
    }

    printf("File copied successfully from '%s' to '%s'\n", argv[1], argv[2]);

    fclose(sourceFile);
    fclose(destFile);
    return 0;
}
-------------------------------------------------------------------------------------------------
gcc mycp.c
./a.out source.txt desti.txt

======================================================================================================
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
======================================================================================================


Implement LS in c 
------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>

int main(int argc, char *argv[]) {
    DIR *dir;
    struct dirent *entry;
    char *path;

    // Default to current directory if no path provided
    if (argc < 2) {
        path = ".";
    } else {
        path = argv[1];
    }

    dir = opendir(path);
    if (dir == NULL) {
        perror("opendir");
        return EXIT_FAILURE;
    }

    while ((entry = readdir(dir)) != NULL) {
        // Skip hidden files (optional: remove this condition to include them)
        if (entry->d_name[0] != '.') {
            printf("%s  ", entry->d_name);
        }
    }

    printf("\n");
    closedir(dir);
    return EXIT_SUCCESS;
}
------------------------------------------------------------------------------------------------
gcc myls.c
./a.out               
./a.out /etc          

======================================================================================================
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
======================================================================================================

Implement MV in C

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>   // for access(), unlink()
#include <errno.h>
#include <string.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <source> <destination>\n", argv[0]);
        return EXIT_FAILURE;
    }

    const char *src = argv[1];
    const char *dest = argv[2];

    // Try rename first (fast if on same filesystem)
    if (rename(src, dest) == 0) {
        printf("Moved successfully from '%s' to '%s'\n", src, dest);
        return EXIT_SUCCESS;
    }

    // If rename fails (cross-device?), fallback to manual copy+delete
    FILE *srcFile = fopen(src, "rb");
    if (!srcFile) {
        perror("Error opening source file");
        return EXIT_FAILURE;
    }

    FILE *destFile = fopen(dest, "wb");
    if (!destFile) {
        perror("Error opening destination file");
        fclose(srcFile);
        return EXIT_FAILURE;
    }

    char buffer[1024];
    size_t bytes;

    while ((bytes = fread(buffer, 1, sizeof(buffer), srcFile)) > 0) {
        if (fwrite(buffer, 1, bytes, destFile) != bytes) {
            perror("Write error");
            fclose(srcFile);
            fclose(destFile);
            return EXIT_FAILURE;
        }
    }

    fclose(srcFile);
    fclose(destFile);

    // Delete original
    if (unlink(src) != 0) {
        perror("Failed to delete original file after copying");
        return EXIT_FAILURE;
    }

    printf("Moved successfully from '%s' to '%s' (via copy + delete)\n", src, dest);
    return EXIT_SUCCESS;
}
-----------------------------------------------------------------------------------------
gcc mymv.c
./a.out oldname.txt newname.txt

======================================================================================================
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
======================================================================================================

frok()
------------------------------------------------------------------------------------------
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>

int main() {
    pid_t pid;

    pid = fork(); // Create a new process

    if (pid < 0) {
        // Fork failed
        perror("fork failed");
        return 1;
    } 
    else if (pid == 0) {
        // This block runs in the child process
        printf("Child Process:\n");
        printf("   PID: %d\n", getpid());
        printf("   Parent PID: %d\n", getppid());
    } 
    else {
        // This block runs in the parent process
        printf("Parent Process:\n");
        printf("   PID: %d\n", getpid());
        printf("   Child PID: %d\n", pid);
    }

    return 0;
}
-----------------------------------------------------------------------------------------------
gcc fork.c
./a.out

======================================================================================================
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
======================================================================================================

Semaphore
-----------------------------------------------------------------------------------------------
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];
int in = 0, out = 0;

sem_t empty;
sem_t full;
pthread_mutex_t mutex;

void* producer(void* arg) {
    int item, i;
    for (i = 0; i < 10; i++) {
        item = i + 1; // Produce item
        sem_wait(&empty); // Wait if buffer is full
        pthread_mutex_lock(&mutex);

        buffer[in] = item;
        printf("Producer produced: %d\n", item);
        in = (in + 1) % BUFFER_SIZE;

        pthread_mutex_unlock(&mutex);
        sem_post(&full); // Increase full count

        sleep(1);
    }
    return NULL;
}

void* consumer(void* arg) {
    int item, i;
    for (i = 0; i < 10; i++) {
        sem_wait(&full); // Wait if buffer is empty
        pthread_mutex_lock(&mutex);

        item = buffer[out];
        printf("Consumer consumed: %d\n", item);
        out = (out + 1) % BUFFER_SIZE;

        pthread_mutex_unlock(&mutex);
        sem_post(&empty); // Increase empty count

        sleep(2);
    }
    return NULL;
}

int main() {
    pthread_t prodThread, consThread;

    sem_init(&empty, 0, BUFFER_SIZE); // buffer is initially empty
    sem_init(&full, 0, 0);            // nothing to consume initially
    pthread_mutex_init(&mutex, NULL);

    pthread_create(&prodThread, NULL, producer, NULL);
    pthread_create(&consThread, NULL, consumer, NULL);

    pthread_join(prodThread, NULL);
    pthread_join(consThread, NULL);

    sem_destroy(&empty);
    sem_destroy(&full);
    pthread_mutex_destroy(&mutex);

    return 0;
}
---------------------------------------------------------------------------------
gcc semaphore.c
./aout

======================================================================================================
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
======================================================================================================

First Fit , Best fit , Worst fit
----------------------------------------------------------------------------------

#include <stdio.h>
#define MAX 50

void firstFit(int blockSize[], int blocks, int processSize[], int processes);
void bestFit(int blockSize[], int blocks, int processSize[], int processes);
void worstFit(int blockSize[], int blocks, int processSize[], int processes);

int main() {
    int blockSize[MAX], processSize[MAX];
    int blocks, processes, i;

    printf("Enter number of memory blocks: ");
    scanf("%d", &blocks);
    printf("Enter sizes of %d blocks:\n", blocks);
    for (i = 0; i < blocks; i++) {
        scanf("%d", &blockSize[i]);
    }

    printf("\nEnter number of processes: ");
    scanf("%d", &processes);
    printf("Enter sizes of %d processes:\n", processes);
    for (i = 0; i < processes; i++) {
        scanf("%d", &processSize[i]);
    }

    printf("\n--- FIRST FIT ---\n");
    firstFit(blockSize, blocks, processSize, processes);

    printf("\n--- BEST FIT ---\n");
    bestFit(blockSize, blocks, processSize, processes);

    printf("\n--- WORST FIT ---\n");
    worstFit(blockSize, blocks, processSize, processes);

    return 0;
}

void firstFit(int blockSize[], int blocks, int processSize[], int processes) {
    int allocation[MAX], bsize[MAX];
    for (int i = 0; i < blocks; i++) bsize[i] = blockSize[i];

    for (int i = 0; i < processes; i++) {
        allocation[i] = -1;
        for (int j = 0; j < blocks; j++) {
            if (bsize[j] >= processSize[i]) {
                allocation[i] = j;
                bsize[j] -= processSize[i];
                break;
            }
        }
    }

    for (int i = 0; i < processes; i++) {
        printf("Process %d (Size %d) -> ", i + 1, processSize[i]);
        if (allocation[i] != -1)
            printf("Block %d\n", allocation[i] + 1);
        else
            printf("Not Allocated\n");
    }
}

void bestFit(int blockSize[], int blocks, int processSize[], int processes) {
    int allocation[MAX], bsize[MAX];
    for (int i = 0; i < blocks; i++) bsize[i] = blockSize[i];

    for (int i = 0; i < processes; i++) {
        int bestIdx = -1;
        allocation[i] = -1;
        for (int j = 0; j < blocks; j++) {
            if (bsize[j] >= processSize[i]) {
                if (bestIdx == -1 || bsize[j] < bsize[bestIdx]) {
                    bestIdx = j;
                }
            }
        }

        if (bestIdx != -1) {
            allocation[i] = bestIdx;
            bsize[bestIdx] -= processSize[i];
        }
    }

    for (int i = 0; i < processes; i++) {
        printf("Process %d (Size %d) -> ", i + 1, processSize[i]);
        if (allocation[i] != -1)
            printf("Block %d\n", allocation[i] + 1);
        else
            printf("Not Allocated\n");
    }
}

void worstFit(int blockSize[], int blocks, int processSize[], int processes) {
    int allocation[MAX], bsize[MAX];
    for (int i = 0; i < blocks; i++) bsize[i] = blockSize[i];

    for (int i = 0; i < processes; i++) {
        int worstIdx = -1;
        allocation[i] = -1;
        for (int j = 0; j < blocks; j++) {
            if (bsize[j] >= processSize[i]) {
                if (worstIdx == -1 || bsize[j] > bsize[worstIdx]) {
                    worstIdx = j;
                }
            }
        }

        if (worstIdx != -1) {
            allocation[i] = worstIdx;
            bsize[worstIdx] -= processSize[i];
        }
    }

    for (int i = 0; i < processes; i++) {
        printf("Process %d (Size %d) -> ", i + 1, processSize[i]);
        if (allocation[i] != -1)
            printf("Block %d\n", allocation[i] + 1);
        else
            printf("Not Allocated\n");
    }
}
------------------------------------------------------------------------------------------------------
gcc fits.c
./a.out

Enter number of memory blocks: 5
Enter sizes of 5 blocks:
100 500 200 300 600

Enter number of processes: 4
Enter sizes of 4 processes:
212 417 112 426
============================================================================================================
